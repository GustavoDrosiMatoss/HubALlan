-- Castle Auto Runner v4 (ASCII-only, no BOM)
-- Enter floor selection + kill mobs + auto portal + auto leave
-- Drop-in: paste into your main script (replacing old Castle/Dungeon section)

-- ===== CONFIG / STATE =====
local castleEnabled = false
local autoLeaveEnabled = false
local killMobsEnabled = true

local enterFloor = 1          -- floor to join on start
local targetLeaveFloor = 999  -- auto leave at this floor (set very high to disable)
local mobClearRadius = 120
local portalDetectRadius = 200

-- ===== SAFE HELPERS =====
local function safe_typeof(v) return (typeof and typeof(v)) or type(v) end
local t_unpack = (table and table.unpack) or unpack

-- ===== SERVICES / PATHS =====
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

local Main = workspace:WaitForChild("__Main")
local World = Main:WaitForChild("__World")
local Enemies = Main:WaitForChild("__Enemies"):WaitForChild("Client")
local Remote = ReplicatedStorage:WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent")

-- ===== CASTLE UTILS =====
local function enterCastleAtFloor(floor)
    local ok, err = pcall(function()
        local args = {
            [1] = {
                [1] = {
                    ["Check"] = true,
                    ["Floor"] = tostring(floor),
                    ["Event"] = "CastleAction",
                    ["Action"] = "Join"
                },
                [2] = "\12"
            }
        }
        if t_unpack then
            Remote:FireServer(t_unpack(args))
        else
            Remote:FireServer(args[1])
        end
    end)
    if ok then
        print("[Castle] Request join floor:", floor)
        return true
    else
        warn("[Castle] Join failed:", err)
        return false
    end
end

local function getNearestFirePortal(maxRadius)
    local nearest, best = nil, math.huge
    for i = 1, 200 do
        local room = World:FindFirstChild("Room_" .. i)
        if room then
            local portal = room:FindFirstChild("FirePortal")
            if portal and portal:IsA("BasePart") then
                local d = (portal.Position - hrp.Position).Magnitude
                if d < best and d <= (maxRadius or 1e9) then
                    best = d
                    nearest = portal
                end
            end
        end
    end
    return nearest
end

local function getCurrentFloor()
    local nearest = getNearestFirePortal(1e9)
    if not nearest then return nil end
    for i = 1, 200 do
        local room = World:FindFirstChild("Room_" .. i)
        if room and room:FindFirstChild("FirePortal") == nearest then
            return i
        end
    end
    return nil
end

local function waitForPortal(timeout)
    local t0 = os.clock()
    repeat
        local p = getNearestFirePortal(portalDetectRadius)
        if p then return p end
        task.wait(0.2)
    until os.clock() - t0 > (timeout or 15)
    return nil
end

local function activateProximityPromptIn(desc)
    if not desc then return false end
    local prompt = desc:FindFirstChildOfClass("ProximityPrompt")
    if not prompt then
        for _, o in ipairs(desc:GetDescendants()) do
            if o:IsA("ProximityPrompt") then
                prompt = o
                break
            end
        end
    end
    if not prompt and desc.Parent then
        prompt = desc.Parent:FindFirstChildOfClass("ProximityPrompt")
    end
    if prompt then
        for _ = 1, 3 do
            pcall(function() fireproximityprompt(prompt) end)
            task.wait(0.05)
        end
        return true
    end
    return false
end

local function tpTo(part)
    if part and part.CFrame then
        hrp.CFrame = part.CFrame
        hrp.Velocity = Vector3.zero
        return true
    end
    return false
end

-- ===== COMBAT =====
local function isAlive(enemy)
    if not enemy or not enemy.Parent then return false end
    local hp = enemy.GetAttribute and enemy:GetAttribute("HP")
    if hp and hp > 0 then return true end
    if safe_typeof(isEnemyDead) == "function" then
        return not isEnemyDead(enemy)
    end
    -- fallback assume alive if unknown
    return true
end

local function approach(enemy)
    if safe_typeof(moveToTarget) == "function" then
        moveToTarget(enemy)
    else
        if enemy and enemy:FindFirstChild("HumanoidRootPart") then
            hrp.CFrame = enemy.HumanoidRootPart.CFrame * CFrame.new(0, 0, 6)
        end
    end
end

local function attackEnemy(enemy)
    if not enemy or not enemy.Parent then return end
    local name = enemy.Name
    pcall(function()
        Remote:FireServer({ { ["Event"] = "ShowPets" }, "\t" })
    end)
    pcall(function()
        Remote:FireServer({
            {
                ["PetPos"] = {},
                ["AttackType"] = "All",
                ["Event"] = "Attack",
                ["Enemy"] = name
            },
            "\7"
        })
    end)
end

local function clearNearbyMobs(radius, maxTime)
    local t0 = os.clock()
    while os.clock() - t0 < (maxTime or 60) do
        local closest, best = nil, math.huge
        for _, enemy in ipairs(Enemies:GetChildren()) do
            if enemy:IsA("Model") and enemy:FindChild("HumanoidRootPart") and isAlive(enemy) then
                local d = (enemy.HumanoidRootPart.Position - hrp.Position).Magnitude
                if d <= (radius or mobClearRadius) and d < best then
                    best = d
                    closest = enemy
                end
            end
        end
        if not closest then return true end
        approach(closest)
        attackEnemy(closest)
        local t1 = os.clock()
        while isAlive(closest) and os.clock() - t1 < 15 do
            task.wait(0.1)
        end
        task.wait(0.1)
    end
    return false
end

-- ===== MAIN LOOP =====
local function autoCastle()
    if enterFloor and enterFloor > 0 then
        enterCastleAtFloor(enterFloor)
        task.wait(3)
    end
    while castleEnabled do
        if killMobsEnabled then
            clearNearbyMobs(mobClearRadius, 45)
        end
        local portal = getNearestFirePortal(portalDetectRadius) or waitForPortal(12)
        if portal then
            tpTo(portal)
            task.wait(0.25)
            activateProximityPromptIn(portal)
            task.wait(1.5)
        else
            task.wait(1.0)
        end
        local floorNow = getCurrentFloor()
        if autoLeaveEnabled and floorNow and floorNow >= targetLeaveFloor then
            if Fluent then
                Fluent:Notify({ Title = "Auto Leave", Content = "Reached floor "..tostring(floorNow)..", leaving...", Duration = 3 })
            end
            if safe_typeof(SetSpawnAndReset) == "function" then
                SetSpawnAndReset("SoloWorld")
            end
            castleEnabled = false
            break
        end
        task.wait(0.5)
    end
end

-- ===== UI (Tabs.dungeon) =====
if Tabs and Tabs.dungeon then
    Tabs.dungeon:AddSection("Castle (Auto Runner v4)")

    Tabs.dungeon:AddInput("CastleEnterFloor", {
        Title = "Enter Floor (Castle)",
        Default = tostring(enterFloor),
        Placeholder = "1, 10, 25...",
        Numeric = true,
        Finished = true,
        Callback = function(value)
            local v = tonumber(value)
            if v and v > 0 then
                enterFloor = v
                print("[Castle] EnterFloor =", enterFloor)
            end
        end
    })

    Tabs.dungeon:AddInput("CastleLeaveFloor", {
        Title = "Auto Leave at Floor",
        Default = tostring(targetLeaveFloor),
        Placeholder = "100 (set high to disable)",
        Numeric = true,
        Finished = true,
        Callback = function(value)
            local v = tonumber(value)
            if v and v > 0 then
                targetLeaveFloor = v
                print("[Castle] LeaveFloor =", targetLeaveFloor)
            end
        end
    })

    Tabs.dungeon:AddToggle("CastleKillMobs", {
        Title = "Kill Mobs Before Portal",
        Default = killMobsEnabled,
        Callback = function(state)
            killMobsEnabled = state
            print("[Castle] KillMobs:", state and "ON" or "OFF")
        end
    })

    Tabs.dungeon:AddToggle("CastleAutoLeave", {
        Title = "Auto Leave",
        Default = autoLeaveEnabled,
        Callback = function(state)
            autoLeaveEnabled = state
            print("[Castle] AutoLeave:", state and "ON" or "OFF")
        end
    })

    Tabs.dungeon:AddToggle("CastleAutoRun", {
        Title = "Auto Castle (Dungeon Integrated)",
        Default = false,
        Callback = function(state)
            castleEnabled = state
            if state then
                if Fluent then
                    Fluent:Notify({ Title = "Auto Castle", Content = "Starting...", Duration = 3 })
                end
                task.spawn(autoCastle)
            else
                if Fluent then
                    Fluent:Notify({ Title = "Auto Castle", Content = "Stopped.", Duration = 3 })
                end
            end
        end
    })
else
    print("[Castle] Tabs.dungeon not found; UI not created.")
end
