-- Allan Hub Arise + Auto Dungeon + Auto Castelo com Config Persistente
-- üî• Agora Auto Dungeon restaura automaticamente quando recarregar o script

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local remote = ReplicatedStorage:WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent")
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer

-- üìÅ Sistema de Configura√ß√£o Global
local configFile = "allan_hub_config.json"
local config = {}

if isfile(configFile) then
    config = HttpService:JSONDecode(readfile(configFile))
else
    config = {
        AutoDungeon = false,
        AutoCastelo = false,
        AutoLeave = false,
        AndarEntrada = 10,
        AndarSaida = 1
    }
end

local function salvarConfig()
    writefile(configFile, HttpService:JSONEncode(config))
end

-- üîπ AUTO DUNGEON (com restaura√ß√£o autom√°tica)
local ativarDungeon = config.AutoDungeon

local tabDungeon = Window:AddTab({
    Title = "Auto Dungeon",
    Icon = "swords"
})

-- Fun√ß√£o simulada de farm (trocar pela real do hub)
local function atacarMobsDungeon()
    while ativarDungeon do
        print("‚öîÔ∏è Farmando mobs da dungeon...")
        task.wait(1)
    end
end

tabDungeon:AddToggle("ToggleAutoDungeon", {
    Title = "Auto Dungeon",
    Description = "Ativa o Auto Dungeon",
    Default = config.AutoDungeon,
    Callback = function(state)
        config.AutoDungeon = state
        salvarConfig()
        ativarDungeon = state
        if ativarDungeon then
            print("‚öîÔ∏è Auto Dungeon ativado!")
            task.spawn(atacarMobsDungeon)
        else
            print("‚ùå Auto Dungeon desativado!")
        end
    end
})

-- üî• Restaurar Auto Dungeon se estava ativo no config
if config.AutoDungeon then
    ativarDungeon = true
    print("‚öîÔ∏è Auto Dungeon restaurado ativo!")
    task.spawn(atacarMobsDungeon)
end

-- üî• AUTO CASTELO
local ativarCastelo = config.AutoCastelo
local ativarAutoLeave = config.AutoLeave
local andarEntrada = config.AndarEntrada
local andarSaida = config.AndarSaida
local currentFloor = 0

local t = Window:AddTab({
    Title = "Auto Castelo",
    Icon = "home"
})

-- Andares Entrada / Sa√≠da
local andaresEntrada, andaresSaida = {}, {}
for i = 10, 110, 10 do table.insert(andaresEntrada, tostring(i)) end
for i = 1, 117 do table.insert(andaresSaida, tostring(i)) end

-- Dropdown Entrada
t:AddDropdown("AndarEntrada", {
    Title = "Selecionar Andar de Entrada",
    Values = andaresEntrada,
    Multi = false,
    Default = tostring(config.AndarEntrada),
    Callback = function(value)
        config.AndarEntrada = tonumber(value)
        salvarConfig()
        andarEntrada = config.AndarEntrada
        print("‚öîÔ∏è Andar de entrada: " .. andarEntrada)
    end
})

-- Dropdown Sa√≠da
t:AddDropdown("AndarSaida", {
    Title = "Selecionar Andar de Sa√≠da (para Auto Leave)",
    Values = andaresSaida,
    Multi = false,
    Default = tostring(config.AndarSaida),
    Callback = function(value)
        config.AndarSaida = tonumber(value)
        salvarConfig()
        andarSaida = config.AndarSaida
        print("üö™ Andar de sa√≠da configurado: " .. andarSaida)
    end
})

-- Toggle Auto Leave
t:AddToggle("ToggleAutoLeave", {
    Title = "Ativar Auto Leave",
    Description = "Se ativo, vai sair no andar selecionado",
    Default = config.AutoLeave,
    Callback = function(state)
        config.AutoLeave = state
        salvarConfig()
        ativarAutoLeave = state
        print(ativarAutoLeave and "üö™ Auto Leave ativado" or "üö™ Auto Leave desativado")
    end
})

-- Fun√ß√£o para usar FirePortal e subir para o pr√≥ximo andar
local function usarFirePortal()
    local char = player.Character or player.CharacterAdded:Wait()
    local hrp = char:WaitForChild("HumanoidRootPart")

    local portal = nil
    local main = workspace:WaitForChild("__Main")
    local world = main:WaitForChild("__World")

    for i = 1, 200 do
        local room = world:FindFirstChild("Room_" .. i)
        if room then
            local foundPortal = room:FindFirstChild("FirePortal")
            if foundPortal then
                portal = foundPortal
                currentFloor = i
                print("üìç ANDAR ATUAL: " .. i)
                break
            end
        end
    end

    if not portal then
        warn("‚ö†Ô∏è FirePortal n√£o encontrado!")
        return
    end

    hrp.CFrame = portal.CFrame
    hrp.Velocity = Vector3.zero
    task.wait(0.1)

    local prompt = portal:FindFirstChildOfClass("ProximityPrompt") or portal:FindFirstChildWhichIsA("ProximityPrompt", true)
    if prompt then
        for i = 1, 3 do
            fireproximityprompt(prompt)
            task.wait(0.05)
        end
        print("üöÄ Subindo para o pr√≥ximo andar!")
    else
        warn("‚ö†Ô∏è ProximityPrompt n√£o encontrado no portal!")
    end
end

-- Fun√ß√£o entrar Castelo
local function entrarCastelo()
    local args = {
        [1] = {
            [1] = {
                ["Check"] = true,
                ["Floor"] = tostring(andarEntrada),
                ["Event"] = "CastleAction",
                ["Action"] = "Join"
            },
            [2] = "\12"
        }
    }
    remote:FireServer(unpack(args))
    print("‚úÖ Entrando no andar " .. andarEntrada)
end

-- Fun√ß√£o sair Castelo
local function sairCastelo()
    local args = {
        [1] = {
            [1] = {
                ["Check"] = true,
                ["Floor"] = tostring(andarSaida),
                ["Event"] = "CastleAction",
                ["Action"] = "LeaveDungeon"
            },
            [2] = "\12"
        }
    }
    remote:FireServer(unpack(args))
    print("‚ùå Saindo no andar " .. andarSaida)
end

-- Fun√ß√£o farmar mobs
local function atacarMobsCastelo()
    while ativarCastelo do
        local target = getNearestEnemy()
        if target and target.Parent then
            anticheat()
            moveToTarget(target)
            task.wait(0.3)
            fireShowPetsRemote()
            remote:FireServer({
                {
                    ["PetPos"] = {},
                    ["AttackType"] = "All",
                    ["Event"] = "Attack",
                    ["Enemy"] = target.Name
                },
                "\7"
            })
            while ativarCastelo and target.Parent and not isEnemyDead(target) do
                task.wait(0.1)
            end
            killedNPCs[target.Name] = true
        else
            task.wait(0.2)
        end
    end
end

-- Monitorar andar atual e sair no andar configurado
local function monitorarAndar()
    ReplicatedStorage:WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent").OnClientEvent:Connect(function(data)
        if typeof(data) == "table" and data[1] and data[1]["Event"] == "PortalAction" then
            local andar = tonumber(data[1]["Floor"])
            if andar then
                currentFloor = andar
                print("üìç Andar atual: " .. currentFloor)
                if ativarCastelo and ativarAutoLeave and currentFloor == andarSaida then
                    sairCastelo()
                end
            end
        end
    end)
end
monitorarAndar()

-- Toggle Auto Castelo
t:AddToggle("ToggleAutoCastelo", {
    Title = "Auto Castelo",
    Description = "Ativa Auto Castelo com farm de mobs",
    Default = config.AutoCastelo,
    Callback = function(state)
        config.AutoCastelo = state
        salvarConfig()
        ativarCastelo = state
        if ativarCastelo then
            print("üî• Auto Castelo ativado!")
            entrarCastelo()
            task.spawn(atacarMobsCastelo)
        else
            print("üõë Auto Castelo desativado!")
        end
    end
})

-- üî• Restaurar Auto Castelo se estava ativo no config
if config.AutoCastelo then
    ativarCastelo = true
    print("üî• Auto Castelo restaurado ativo!")
    entrarCastelo()
    task.spawn(atacarMobsCastelo)
end
